#include "Sellpoint.h"
#include "Enemy.h"
#include "Spider.h"
#include "Player.h"
#include "GreenDragon.h"

Sellpoint::Sellpoint(const CVector3D& pos): Carry(eSellpoint),m_totalEarnings(0.0f), m_isSellFrag(false),
m_showEarnings(false), m_displayDuration(0.0f), m_elapsedDisplayTime(0.0f), m_displayedEarnings(0.0f)
{
	m_rad = 0.6f;
	m_pos = pos;
	m_isSellFrag = false;
}

void Sellpoint::Update()
{
	if (m_showEarnings) {
		//徐々に金額を目標金額に近づける
		if (m_displayedEarnings < m_totalEarnings)
		{
			float increment = (m_totalEarnings - m_displayedEarnings) * 0.1f;
			m_displayedEarnings += increment;
			//効果音を再生する
			if (!buyPlayed)
			{
				SOUND("売却中")->Play();
				buyPlayed = true;
			}

			//誤差を避けるため、最終的にピッタリ合わせる
			if (fabs(m_displayedEarnings - m_totalEarnings) < 0.01f)
			{
				m_displayedEarnings = m_totalEarnings;

				//効果音を再生する
				if (!soundPlayed)
				{
					SOUND("売却中")->Stop();
					SOUND("売却音")->Play();
					soundPlayed = true;
				}
			}
		}

		//表示時間を管理
		m_elapsedDisplayTime += CFPS::GetDeltaTime();
		if (m_elapsedDisplayTime >= m_displayDuration)
		{
			m_showEarnings = false;  // 通知を非表示
			m_elapsedDisplayTime = 0.0f;  // 時間リセット
			m_totalEarnings = 0.0f;       // 総額リセット
			m_displayedEarnings = 0.0f;   // 表示金額リセット

			//効果音のフラグをリセット
			soundPlayed = false;
			buyPlayed = false;
		}
	}
}

void Sellpoint::Render()
{
	m_lineS = m_pos + CVector3D(0, 2.0f - m_rad, 0);
	m_lineE = m_pos + CVector3D(0, m_rad, 0);
	//Utility::DrawOBB(m_obb, CVector4D(1, 1, 0, 0.5));

	Utility::DrawCapsule(m_lineS, m_lineE, m_rad, CVector4D(0, 1, 0, 0.5));

	 if (m_showEarnings) 
	 {
        std::wstring totalText = L"総売却金額: " + std::to_wstring(static_cast<int>(m_displayedEarnings)) + L" G";
        m_renderer.DrawTextWindow(100, 100, 400, 100, totalText.c_str(),
            CVector4D(0.0f, 0.0f, 0.0f, 0.7f),  // 背景色
            CVector3D(1.0f, 1.0f, 1.0f),        // 文字色
            10);                                // パディング
    }
}

void Sellpoint::Collision(Base* b)
{
	switch (b->GetType())
	{
	case ePlayer:
		if (Player* player = dynamic_cast<Player*>(b))
		{
			if (!Base::FindObject(eEnemy))return;
			
				//カプセル同士の衝突
				if (CCollision::CollisionCapsule(player->m_lineS, player->m_lineE, player->m_rad,
					m_lineS, m_lineE, m_rad))
				{
					FONT_T()->Draw(1500, 750, 1.0f, 1.0f, 1.0f, "気絶した敵を落とし");
					FONT_T()->Draw(1500, 850, 1.0f, 1.0f, 1.0f, "クリックで売却");
					
					if (PUSH(CInput::eMouseL)) {
						m_isSellFrag = true;
					}
					else {
						m_isSellFrag = false;
					}
				}
		}
		break;
	case eEnemy:
		//敵と売却地点
	
		if (Enemy* enemy = dynamic_cast<Enemy*>(b))
			//カプセル同士の衝突
			if (CCollision::CollisionCapsule(enemy->m_lineS, enemy->m_lineE, enemy->m_rad,
				m_lineS, m_lineE, m_rad))
		{	
			//敵のHPが0の時売却できる
			if (enemy->GetHP() <= 0&& m_isSellFrag&&enemy->m_stateItem !=e_Equip)
			{
				//	printf("baikyaku\n");
					enemy->SetKill();
					int earnings1 = 300;
					enemy->GiveMoney(earnings1);
					TriggerEarnings(300);
				//	printf("%s", enemy);
			}
		}if (Spider* spider = dynamic_cast<Spider*>(b))
			//カプセル同士の衝突
			if (CCollision::CollisionCapsule(spider->m_lineS, spider->m_lineE, spider->m_rad,
				m_lineS, m_lineE, m_rad))
			{

				//敵のHPが0の時売却できる
				if (spider->GetHP() <= 0 && m_isSellFrag &&spider->m_stateItem != e_Equip)
				{
					//printf("baikyaku\n");
					spider->SetKill();
					int earnings2 = 450;
					spider->GiveMoney(earnings2);
					TriggerEarnings(450);
					//printf("%s", spider);
				}
			}
		if (GreenDragon* dragon = dynamic_cast<GreenDragon*>(b))
			//カプセル同士の衝突
			if (CCollision::CollisionCapsule(dragon->m_lineS, dragon->m_lineE, dragon->m_rad,
				m_lineS, m_lineE, m_rad))
			{

				//敵のHPが0の時売却できる
				if (dragon->GetHP() <= 0 && m_isSellFrag && dragon->m_stateItem != e_Drop)
				{
					//printf("baikyaku\n");
					dragon->SetKill();
					int earnings3 = 1050;
					dragon->GiveMoney(earnings3);
					TriggerEarnings(1050);
					//printf("%s", spider);
				}
			}
	break;
	}
}

void Sellpoint::TriggerEarnings(int earnings)
{
	m_totalEarnings += earnings;   // 総額を加算
	m_showEarnings = true;         // 通知を表示
	m_displayDuration = 3.0f;      // 表示時間を設定
	m_elapsedDisplayTime = 0.0f;   // 表示経過時間をリセット
}
